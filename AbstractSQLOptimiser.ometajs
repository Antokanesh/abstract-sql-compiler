var _ = require('lodash');

ometa AbstractSQLValidator {

	Query =
		SelectQuery,

	SelectQuery =
		[	'UnionQuery'
			SelectQuery:first
			SelectQuery+:rest
		]
		-> [ 'UnionQuery', first ].concat(rest)
	|	[	'SelectQuery'
			{['SelectQuery']}:query
			(	(	?(select==null)
					Select:select
				|	//?(from==null)
					Table:from
				|	Join
				|	?(where==null)
					Where:where
				|	?(groupBy==null)
					GroupBy:groupBy
				|	?(orderBy==null)
					OrderBy:orderBy
				|	?(limit==null)
					Limit:limit
				|	?(offset==null)
					Offset:offset
				):queryPart
				{query.concat(queryPart)}:query
			)+
			?(select!=null)
		]
		-> query,

	DeleteQuery =
		[	'DeleteQuery'
			{['DeleteQuery']}:query
			(	(	Table:table
				|	?(where==null)
					Where:where
				):queryPart
				{query.concat(queryPart)}:query
			)*
			?(table!=null)
		]
		-> query,

	UpsertQuery =
		[	'UpsertQuery'
			InsertQuery:insert
			UpdateQuery:update
		]
		-> ['UpsertQuery', insert, update],

	InsertQuery =
		[	'InsertQuery'
			InsertBody:body
		]
		-> ['InsertQuery'].concat(body),

	UpdateQuery =
		[	'UpdateQuery'
			UpdateBody:body
		]
		-> ['UpdateQuery'].concat(body),

	InsertBody =
		{[]}:body
		(	// Ignore/strip where clauses for inserts.
			Where
		|	Table:table
			{body.concat(table)}:body
		|	Fields:fields
		|	Values:values
		)+
		?(fields!=null)
		?(values!=null)
		?(table!=null)
		// Make sure the body is in the correct order.
		{body.concat(fields, values)}:body
		-> body,

	UpdateBody =
		{[]}:body
		(	Table:table
			{body.concat(table)}:body
		|	Fields:fields
		|	Values:values
		|	?(where==null)
			Where:where
		)+
		?(fields!=null && fields[0].length > 0)
		?(values!=null && values[0].length > 0)
		?(table!=null)
		// Make sure the body is in the correct order.
		{body.concat(fields, values)}:body
		(	?where
			{body.concat(where)}:body
		)?
		-> body,

	Fields =
		[	'Fields'
			[	anything*:fields
			]
		]
		-> [['Fields', fields]],

	Values =
		[	'Values'
			(	SelectQuery:values
			|	[	(	'?'
					|	true
					|	false
					|	Null
					|	Bind
					|	Default
					|	anything
					)*:values
				]
			)
		]
		-> [['Values', values]],

	Default =
		'Default',

	Select =
		[	'Select'
			[	(	[	SelectField:field
						anything:as
					]
					-> [field, as]
				|	SelectField
				|	[	:table
						'*'
					]
				|	'*'
				)*:fields
			]
		]
		-> [['Select', fields]],

	SelectField =
			Count
		|	AnyValue
		|	Null
	,

	Count =
		[
			'Count'
			'*'
		],


	Table =
		[	'From'
			(	~string
				[	(	SelectQuery
					|	anything
					):table
					anything:as
				]
				-> [table, as]
			|	SelectQuery
			|	anything
			):from
		]
		-> [['From', from]],

	Join =
		[	'Join'
			[	'With'
				:table
			]
			[	'On'
				BooleanValue:boolStatement
			]
		]
		-> [['Join', ['With', table], ['On', boolStatement]]],

	Where =
		[	'Where'
			BooleanValue:boolStatement
		]
		-> [['Where', boolStatement]],

	GroupBy =
		[	'GroupBy'
			[	AnyValue+:values
			]
		]
		-> [['GroupBy', values]],

	OrderBy =
		[	'OrderBy'
			(	[	(	'ASC'
					|	'DESC'
					):order
					Field:field
				]
				-> [order, field]
			)+:orders
		]
		-> [['OrderBy'].concat(orders)],

	Limit =
		[	'Limit'
			NumericValue:num
		]
		-> [['Limit', num]],

	Offset =
		[	'Offset'
			NumericValue:num
		]
		-> [['Offset', num]],

	AnyValue =
			UnknownValue
		|	TextValue
		|	NumericValue
		|	BooleanValue
		|	DateValue
		|	JSONValue
		|	DurationValue,

	UnknownValue =
		(	Field
		|	Bind
		|	Null
		|	Cast
		|	SelectQuery
		),

	Field =
			ReferencedField
		|	UnreferencedField,

	UnreferencedField =
		[	'Field'
			:field
		],

	ReferencedField =
		[	'ReferencedField'
			:table
			:field
		],

	Bind =
		[	'Bind'
			(	number
			|	:tableName
				:field
			)
		],

	Null =
		:next
		?(next === null || next === 'Null')
		-> null,

	Cast =
		[	'Cast'
			AnyValue:v
			:as
		]
		-> ['Cast', v, as],

	TextValue =
		(	UnknownValue
		|	Text
		|	Concat
		|	Lower
		|	Upper
		|	Trim
		|	Replace
		|	Substring
		|	Right
		),

	Text =
		[	(	'Value'
			|	'Text'
			)
			:text
		],

	Concat =
		[	(	'Concat'
			|	'Concatenate'
			)
			TextValue:firstString
			TextValue+:otherStrings
		]
		-> ['Concatenate', firstString].concat(otherStrings),

	Lower =
		[	(	'Tolower'
			|	'ToLower'
			|	'Lower'
			)
			TextValue:string
		]
		-> ['Lower', string],

	Upper =
		[	(	'Toupper'
			|	'ToUpper'
			|	'Upper'
			)
			TextValue:string
		]
		-> ['Upper', string],

	Trim =
		[	'Trim'
			TextValue:str
		]
		-> ['Trim', str],

	Replace =
		[	'Replace'
			TextValue:string
			TextValue:find
			TextValue:replacement
		]
		-> ['Replace', string, find, replacement],

	Substring =
		[	'Substring'
			TextValue:string
			NumericValue+:args
		]
		-> ['Substring', string].concat(args),

	Right :indent =
		[	'Right'
			TextValue:string
			NumericValue:n
		]
		-> ['Right', string, n],

	NumericValue =
		(	UnknownValue
		|	Number
		|	MathOp
		|	BitwiseAnd
		|	BitwiseShiftRight
		|	CharacterLength
		|	IndexOf
		|	StrPos
		|	Year
		|	Month
		|	Day
		|	Hour
		|	Minute
		|	Second
		|	FractionalSeconds
		|	TotalSeconds
		|	Round
		|	Floor
		|	Ceiling
		),

	// TODO: Integer should actually be separate from number, for the case of bitwise operations that need an integral type.
	Number =
		[	(	'Number'
			|	'Real'
			|	'Integer'
			)
			:number
		],

	MathOp =
		(	Add
		|	Subtract
		|	Multiply
		|	Divide
		),

	Add =
		[	'Add'
			NumericValue:lhs
			NumericValue:rhs
		]
		-> ['Add', lhs, rhs],

	Subtract =
		[	'Subtract'
			NumericValue:lhs
			NumericValue:rhs
		]
		-> ['Subtract', lhs, rhs],

	Multiply =
		[	'Multiply'
			NumericValue:lhs
			NumericValue:rhs
		]
		-> ['Multiply', lhs, rhs],

	Divide =
		[	'Divide'
			NumericValue:lhs
			NumericValue:rhs
		]
		-> ['Divide', lhs, rhs],

	BitwiseAnd =
		[	'BitwiseAnd'
			NumericValue:operand
			NumericValue:mask
		]
		-> ['BitwiseAnd', operand, mask],

	BitwiseShiftRight =
		[	'BitwiseShiftRight'
			NumericValue:operand
			NumericValue:shift
		]
		-> ['BitwiseShiftRight', operand, shift],

	CharacterLength =
		[	'CharacterLength'
			TextValue:text
		]
		-> ['CharacterLength', text],

	IndexOf =
		[	(	'IndexOf'
			|	'Indexof'
			)
			TextValue:haystack
			TextValue:needle
		]
		SetHelped
		-> ['Subtract', ['StrPos', haystack, needle], ['Number', 1]],

	StrPos =
		[	(	'StrPos'
			|	'InStr'
			)
			TextValue:haystack
			TextValue:needle
		]
		-> ['StrPos', haystack, needle],

	Year =
		[	'Year'
			DateValue:date
		]
		-> ['Year', date],

	Month =
		[	'Month'
			DateValue:date
		]
		-> ['Month', date],

	Day =
		[	'Day'
			DateValue:date
		]
		-> ['Day', date],

	Hour =
		[	'Hour'
			DateValue:date
		]
		-> ['Hour', date],

	Minute =
		[	'Minute'
			DateValue:date
		]
		-> ['Minute', date],

	Second =
		[	'Second'
			DateValue:date
		]
		-> ['Second', date],

	FractionalSeconds =
		[	'Fractionalseconds'
			DateValue:date
		]
		-> ['Fractionalseconds', date],

	TotalSeconds =
		[	'Totalseconds'
			DurationValue:duration
		]
		-> ['Totalseconds', duration],

	Round =
		[	'Round'
			NumericValue:num
		]
		-> ['Round', num],

	Floor =
		[	'Floor'
			NumericValue:num
		]
		-> ['Floor', num],

	Ceiling =
		[	'Ceiling'
			NumericValue:num
		]
		-> ['Ceiling', num],

	BooleanValue =
		(	UnknownValue
		|	Boolean
		|	And
		|	Not
		|	Or
		|	Exists
		|	NotExists
		|	Comparison
		|	Between
		|	In
		|	NotIn
		),

	Boolean =
		[	'Boolean'
			(	true
			|	false
			):bool
		]
		-> ['Boolean', bool],

	Not =
		[	'Not'
			BooleanValue:bool
		]
		-> ['Not', bool],

	And =
		[	'And'
			BooleanValue:firstBool
			BooleanValue+:otherBools
		]
		-> ['And', firstBool].concat(otherBools),

	Or =
		[	'Or'
			BooleanValue:firstBool
			BooleanValue+:otherBools
		]
		-> ['Or', firstBool].concat(otherBools),

	NotExists =
		[	'NotExists'
			AnyValue:exists
		]
		-> ['NotExists', exists],

	Exists =
		[	'Exists'
			AnyValue:exists
		]
		-> ['Exists', exists],

	Comparison =
		(	Equals
		|	GreaterThan
		|	GreaterThanOrEqual
		|	LessThan
		|	LessThanOrEqual
		|	NotEquals
		|	Like
		),

	Equals =
		[	'Equals'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['Equals', comp1, comp2],

	GreaterThan =
		[	'GreaterThan'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['GreaterThan', comp1, comp2],

	GreaterThanOrEqual =
		[	'GreaterThanOrEqual'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['GreaterThanOrEqual', comp1, comp2],

	LessThan =
		[	'LessThan'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['LessThan', comp1, comp2],

	LessThanOrEqual =
		[	'LessThanOrEqual'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['LessThanOrEqual', comp1, comp2],

	NotEquals =
		[	'NotEquals'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['NotEquals', comp1, comp2],

	Like =
		[	'Like'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['Like', comp1, comp2],

	Between =
		[	'Between'
			AnyValue:comp1
			AnyValue:comp2
			AnyValue:comp3
		]
		-> ['Between', comp1, comp2, comp3],

	In =
		[	'In'
			Field:field
			AnyValue+:vals
		]
		-> ['In', field].concat(vals),

	NotIn =
		[	'NotIn'
			Field:field
			AnyValue+:vals
		]
		-> ['NotIn', field].concat(vals),

	DateValue =
		(	UnknownValue
		|	Date
		|	ToDate
		|	ToTime
		|	Now
		),

	Date =
		[	'Date'
			anything:date
		]
		?_.isDate(date)
		-> ['Date', date],

	ToDate =
		[	'ToDate'
			DateValue:date
		]
		-> ['ToDate', date],

	ToTime =
		[	'ToTime'
			DateValue:date
		]
		-> ['ToTime', date],

	Now =
		['Now']
		-> ['Now'],

	JSONValue =
		(	UnknownValue
		|	AggregateJSON
		),

	AggregateJSON =
		[	'AggregateJSON'
			anything:field
		]
		-> ['AggregateJSON', field],

	DurationValue =
		(	UnknownValue
		|	Duration
		),

	Duration =
		[	'Duration'
			anything:duration
		]
		?_.isObject(duration)
		{	_(duration)
			.pick('negative', 'day', 'hour', 'minute', 'second')
			.omitBy(_.isNil)
			.pickBy(function(value, key) {
				if(key === 'negative') {
					return _.isBoolean(value);
				}
				return _.isNumber(value);
			})
			.value()
		}:duration
		?(!_(duration).omit('negative').isEmpty())
		-> ['Duration', duration]
}

export ometa AbstractSQLOptimiser <: AbstractSQLValidator {

	// TODO: NotEquals 0 -> Exists?

	// AndApply :rule =
		// (	apply(actual)
		// |	'And'
			// (	AndApply(rule)
			// |	BooleanValue
			// )
			// (	AndApply(rule)
			// |	BooleanValue
			// )+
		// ),

	// WhereExists =
		// [	'Exists'
			// Query
		// ]

	// Where =
			// [	'Where'
				// AndApply('WhereExists')

				// // [	'Not'
					// // Exists:exists
					// // ?(exists[1][0] == 'Query')
					// // {[]}:queryAdditions
					// // {console.log('x', exists);}
					// // {exists[1].slice(1)}:queryClauses
					// // {console.log('t', queryClauses);}
					// // {	for(var i=0; i<queryClauses.length;i++) {
							// // switch(queryClauses[i][0]) {
								// // case 'Select':
								// // break;
								// // case 'From':
								// // case 'Join':
									// // queryAdditions.push(['LeftJoin', queryClauses[i][1]]);
								// // break;
								// // case 'Where':
									// // queryAdditions.push(queryClauses[i]);
								// // break;
								// // default:
									// // console.log('x', queryClauses);
									// // throw 'Defaulted in Where Exists Query: "' + queryClauses[i] + '"';
							// // }
						// // }
					// // }
				// // ]
			// ]
			// {console.log('Wooo')}
			// SetHelped
			// -> queryAdditions
		// |	^Where,

	FieldNotEquals =
		[	'NotEquals'
			(	Field:comp1
				AnyValue:comp2
			|	AnyValue:comp2
				Field:comp1
			)
		]
		-> ['NotEquals', comp1, comp2],

	FieldEquals =
		[	'Equals'
			(	Field:comp1
				AnyValue:comp2
			|	AnyValue:comp2
				Field:comp1
			)
		]
		-> ['Equals', comp1, comp2],

	Or =
			// Optimise id = 1 OR id = 2 OR id = 3 -> id IN [1, 2, 3]
			[	'Or'
				FieldEquals:firstBool
				(	FieldEquals:secondBool
					?_.isEqual(firstBool[1], secondBool[1])
					-> secondBool[2]
				)+:inVals
				BooleanValue*:otherBools
			]
			SetHelped
			{['In', firstBool[1], firstBool[2]].concat(inVals)}:inStatement
			(	?(otherBools.length > 0)
				-> ['Or', inStatement].concat(otherBools)
			|	-> inStatement
			)
		|	// Collapse nested ORs.
			[	'Or'
				{[]}:conditions
				(	^Or:or
					{conditions.concat(or.slice(1))}:conditions
					SetHelped
				|	BooleanValue:bool
					{conditions.push(bool)}
				)+
			]
			-> ['Or'].concat(conditions)
		|	^Or,

	And =
			// Optimise id != 1 AND id != 2 AND id != 3 -> id NOT IN [1, 2, 3]
			[	'And'
				FieldNotEquals:firstBool
				(	FieldNotEquals:secondBool
					?_.isEqual(firstBool[1], secondBool[1])
					-> secondBool[2]
				)+:inVals
				BooleanValue*:otherBools
			]
			SetHelped
			{['NotIn', firstBool[1], firstBool[2]].concat(inVals)}:inStatement
			(	?(otherBools.length > 0)
				-> ['Or', inStatement].concat(otherBools)
			|	-> inStatement
			)
		|	// Collapse nested ANDs.
			[	'And'
				{[]}:conditions
				(	And:and
					{conditions.concat(and.slice(1))}:conditions
					SetHelped
				|	BooleanValue:bool
					{conditions.push(bool)}
				)+
			]
			-> ['And'].concat(conditions)
		|	^And,

	Not =
		(	[	'Not'
				(	[	'Not'
						BooleanValue:boolStatement
					]
				|	(	Equals:boolStatement
						-> 'NotEquals'
					|	NotEquals:boolStatement
						-> 'Equals'
					|	In:boolStatement
						-> 'NotIn'
					|	NotIn:boolStatement
						-> 'In'
					|	Exists:boolStatement
						-> 'NotExists'
					|	NotExists:boolStatement
						-> 'Exists'
					):replace
					{boolStatement[0] = replace}
				)
			]
			SetHelped
			-> boolStatement
		|	^Not
		),

	NotEquals =
			// Convert not equals null to exists.
			[	'NotEquals'
				(	Null
					AnyValue:value
				|	AnyValue:value
					Null
				)
			]
			SetHelped
			-> ['Exists', value]
		|	^NotEquals,

	Equals =
			// Convert equals null to exists.
			[	'Equals'
				(	Null
					AnyValue:value
				|	AnyValue:value
					Null
				)
			]
			SetHelped
			-> ['Not', ['Exists', value]]
		|	^Equals,

	BooleanValue =
			Contains
		|	StartsWith
		|	EndsWith
		|	^BooleanValue,

	Contains =
		[	'Contains'
			TextValue:haystack
			TextValue:needle
		|	'Substringof'
			TextValue:needle
			TextValue:haystack
		]
		SetHelped
		-> ['GreaterThan', ['StrPos', haystack, needle], ['Number', 0]],

	StartsWith =
		[	'Startswith'
			TextValue:haystack
			TextValue:needle
		]
		SetHelped
		-> ['Equals', ['StrPos', haystack, needle], ['Number', 1]],

	EndsWith =
		[	'Endswith'
			TextValue:haystack
			TextValue:needle
		]
		SetHelped
		-> ['Equals', ['Right', haystack, ['CharacterLength', needle]], needle],

	Helped :disableMemoisationHack =
		?(this.helped === true)
		{this.helped = false},

	SetHelped =
		{this.helped = true},

	Process =
		:query
		// Make sure we can at least do one valid pass.
		(	AnyValue(query)
		|	SelectQuery(query)
		|	InsertQuery(query)
		|	UpdateQuery(query)
		|	DeleteQuery(query)
		|	UpsertQuery(query)
		):query
		(	Helped('disableMemoisation')
			(	AnyValue(query)
			|	SelectQuery(query)
			|	InsertQuery(query)
			|	UpdateQuery(query)
			|	DeleteQuery(query)
			|	UpsertQuery(query)
			):query
		)*
		-> query
}

AbstractSQLOptimiser.initialize = function() {
	this.helped = false;
};
