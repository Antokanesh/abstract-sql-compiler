ometa AbstractSQLValidator {

	Query =
		SelectQuery,

	SelectQuery =
		[	'SelectQuery'
			{['SelectQuery']}:query
			(	(	?(select==null)
					Select:select
				|	//?(from==null)
					Table:from
				|	Join
				|	?(where==null)
					Where:where
				|	?(orderBy==null)
					OrderBy:orderBy
				|	?(limit==null)
					Limit:limit
				|	?(offset==null)
					Offset:offset
				):queryPart
				{query.concat(queryPart)}:query
			)+
			?(select!=null)
			?(from!=null)
		]
		-> query,

	DeleteQuery =
		[	'DeleteQuery'
			{['DeleteQuery']}:query
			(	(	Table:table
				|	?(where==null)
					Where:where
				):queryPart
				{query.concat(queryPart)}:query
			)*
			?(table!=null)
		]
		-> query,

	UpsertQuery =
		[	'UpsertQuery'
			UpdateBody:body
		]
		-> ['UpsertQuery'].concat(body),

	InsertQuery =
		[	'InsertQuery'
			InsertBody:body
		]
		-> ['InsertQuery'].concat(body),

	UpdateQuery =
		[	'UpdateQuery'
			UpdateBody:body
		]
		-> ['UpdateQuery'].concat(body),

	InsertBody =
		{[]}:body
		(	(	Fields:fieldValues
			|	Table:table
			):bodyPart
			{body.concat(bodyPart)}:body
		)+
		?(fieldValues!=null)
		?(table!=null)
		-> body,

	UpdateBody =
		{[]}:body
		(	(	Fields:fieldValues
			|	Table:table
			|	?(where==null)
				Where:where
			):bodyPart
			{body.concat(bodyPart)}:body
		)+
		?(fieldValues!=null)
		?(table!=null)
		-> body,

	Fields =
		[	'Fields'
			[	(	[	anything:field
						(	'?'
						|	true
						|	false
						|	Null
						|	Bind
						|	anything
						):value
					]
					-> [field, value]
				)+:fields
			]
		]
		-> [['Fields', fields]],

	Select =
		[	'Select'
			[	(	Count
				|	[	:table
						'*'
					]
				|	[	(	Field
						|	ReferencedField
						):field
						anything:as
					]
					-> [field, as]
				|	Field
				|	ReferencedField
				|	'*'
				|	Null
				)*:fields
			]
		]
		-> [['Select', fields]],

	Count =
		[	'Count'
			'*'
		],

	Table =
		[	'From'
			:table
			anything?:as
		]
		(	?(as != null)
			-> [['From', table, as]]
		|	-> [['From', table]]
		),

	Join =
		[	'Join'
			[	'With'
				:table
			]
			[	'On'
				BooleanValue:boolStatement
			]
		]
		-> [['Join', ['With', table], ['On', boolStatement]]],

	Where =
		[	'Where'
			BooleanValue:boolStatement
		]
		-> [['Where', boolStatement]],

	OrderBy =
		[	'OrderBy'
			(	[	(	'ASC'
					|	'DESC'
					):order
					(	Field
					|	ReferencedField
					):field
				]
				-> [order, field]
			)+:orders
		]
		-> [['OrderBy'].concat(orders)],

	Limit =
		[	'Limit'
			NumericValue:num
		]
		-> [['Limit', num]],

	Offset =
		[	'Offset'
			NumericValue:num
		]
		-> [['Offset', num]],

	AnyValue =
			UnknownValue
		|	TextValue
		|	NumericValue
		|	BooleanValue,

	UnknownValue =
		(	ReferencedField
		|	Field
		|	Bind
		|	Null
		|	SelectQuery
		),

	Field =
		[	'Field'
			:field
		],

	ReferencedField =
		[	'ReferencedField'
			:table
			:field
		],

	Bind =
		[	'Bind'
			:tableName
			:field
		],

	Null =
		:next
		?(next===null)
		-> null,

	TextValue =
		(	UnknownValue
		|	Text
		|	Concat
		),

	Text =
		[	(	'Value'
			|	'Text'
			)
			:text
		],

	Concat =
		[	(	'Concat'
			|	'Concatenate'
			)
			TextValue:firstString
			TextValue+:otherStrings
		]
		-> ['Concatenate', firstString].concat(otherStrings),

	NumericValue =
		(	UnknownValue
		|	Number
		|	MathOp
		|	BitwiseAnd
		|	BitwiseShiftRight
		|	CharacterLength
		),

	// TODO: Integer should actually be separate from number, for the case of bitwise operations that need an integral type.
	Number =
		[	(	'Number'
			|	'Real'
			|	'Integer'
			)
			:number
		],

	MathOp =
		(	Add
		|	Subtract
		|	Multiply
		|	Divide
		),

	Add =
		[	'Add'
			NumericValue:lhs
			NumericValue:rhs
		]
		-> ['Add', lhs, rhs],

	Subtract =
		[	'Subtract'
			NumericValue:lhs
			NumericValue:rhs
		]
		-> ['Subtract', lhs, rhs],

	Multiply =
		[	'Multiply'
			NumericValue:lhs
			NumericValue:rhs
		]
		-> ['Multiply', lhs, rhs],

	Divide =
		[	'Divide'
			NumericValue:lhs
			NumericValue:rhs
		]
		-> ['Divide', lhs, rhs],

	BitwiseAnd =
		[	'BitwiseAnd'
			NumericValue:operand
			NumericValue:mask
		]
		-> ['BitwiseAnd', operand, mask],

	BitwiseShiftRight =
		[	'BitwiseShiftRight'
			NumericValue:operand
			NumericValue:shift
		]
		-> ['BitwiseShiftRight', operand, shift],

	CharacterLength =
		[	'CharacterLength'
			TextValue:text
		]
		-> ['CharacterLength', text],

	BooleanValue =
		(	UnknownValue
		|	Boolean
		|	And
		|	Not
		|	Or
		|	Exists
		|	Comparison
		|	Between
		),

	Boolean =
		[	'Boolean'
			(	true
			|	false
			):bool
		]
		-> ['Boolean', bool],

	Not =
		[	'Not'
			BooleanValue:bool
		]
		-> ['Not', bool],

	And =
		[	'And'
			BooleanValue:firstBool
			BooleanValue+:otherBools
		]
		-> ['And', firstBool].concat(otherBools),

	Or =
		[	'Or'
			BooleanValue:firstBool
			BooleanValue+:otherBools
		]
		-> ['Or', firstBool].concat(otherBools),

	Exists =
		[	'Exists'
			AnyValue:exists
		]
		-> ['Exists', exists],

	Comparison =
		(	Equals
		|	GreaterThan
		|	GreaterThanOrEqual
		|	LessThan
		|	LessThanOrEqual
		|	NotEquals
		|	Like
		),

	Equals =
		[	'Equals'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['Equals', comp1, comp2],

	GreaterThan =
		[	'GreaterThan'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['GreaterThan', comp1, comp2],

	GreaterThanOrEqual =
		[	'GreaterThanOrEqual'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['GreaterThanOrEqual', comp1, comp2],

	LessThan =
		[	'LessThan'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['LessThan', comp1, comp2],

	LessThanOrEqual =
		[	'LessThanOrEqual'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['LessThanOrEqual', comp1, comp2],

	NotEquals =
		[	'NotEquals'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['NotEquals', comp1, comp2],

	Like =
		[	'Like'
			AnyValue:comp1
			AnyValue:comp2
		]
		-> ['Like', comp1, comp2],

	Between =
		[	'Between'
			AnyValue:comp1
			AnyValue:comp2
			AnyValue:comp3
		]
		-> ['Between', comp1, comp2, comp3]
}

export ometa AbstractSQLOptimiser <: AbstractSQLValidator {

	// TODO: NotEquals 0 -> Exists?

	// AndApply :rule =
		// (	apply(actual)
		// |	'And'
			// (	AndApply(rule)
			// |	BooleanValue
			// )
			// (	AndApply(rule)
			// |	BooleanValue
			// )+
		// ),

	// WhereExists =
		// [	'Exists'
			// Query
		// ]

	// Where =
			// [	'Where'
				// AndApply('WhereExists')

				// // [	'Not'
					// // Exists:exists
					// // ?(exists[1][0] == 'Query')
					// // {[]}:queryAdditions
					// // {console.log('x', exists);}
					// // {exists[1].slice(1)}:queryClauses
					// // {console.log('t', queryClauses);}
					// // {	for(var i=0; i<queryClauses.length;i++) {
							// // switch(queryClauses[i][0]) {
								// // case 'Select':
								// // break;
								// // case 'From':
								// // case 'Join':
									// // queryAdditions.push(['LeftJoin', queryClauses[i][1]]);
								// // break;
								// // case 'Where':
									// // queryAdditions.push(queryClauses[i]);
								// // break;
								// // default:
									// // console.log('x', queryClauses);
									// // throw 'Defaulted in Where Exists Query: "' + queryClauses[i] + '"';
							// // }
						// // }
					// // }
				// // ]
			// ]
			// {console.log('Wooo')}
			// SetHelped
			// -> queryAdditions
		// |	^Where,

	Not =
		(	[	'Not'
				(	[	'Not'
						BooleanValue:boolStatement
					]
				|	Equals:boolStatement
					{boolStatement[0] = 'NotEquals'}
				)
			]
			SetHelped
			-> boolStatement
		// |	[	'Exists'
				// [	'SelectQuery'
					// TODO: ?
				// ]
			// ]
		|	^Not
		),

	Helped :disableMemoisationHack =
		?(this.helped === true)
		{this.helped = false},

	SetHelped =
		{this.helped = true},

	Process =
		:query
		// Make sure we can at least do one valid pass.
		(	AnyValue(query)
		|	SelectQuery(query)
		|	InsertQuery(query)
		|	UpdateQuery(query)
		|	DeleteQuery(query)
		|	UpsertQuery(query)
		):query
		(	Helped('disableMemoisation')
			(	AnyValue(query)
			|	SelectQuery(query)
			|	InsertQuery(query)
			|	UpdateQuery(query)
			|	DeleteQuery(query)
			|	UpsertQuery(query)
			):query
		)*
		-> query
}

AbstractSQLOptimiser.initialize = function() {
	this.helped = false;
};
