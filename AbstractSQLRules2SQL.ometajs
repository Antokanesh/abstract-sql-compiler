var comparisons = {
		'Equals': ' = ',
		'GreaterThan': ' > ',
		'GreaterThanOrEqual': ' >= ',
		'LessThan': ' < ',
		'LessThanOrEqual': ' <= ',
		'NotEquals': ' != ',
		'Like': ' LIKE '
	};

export ometa AbstractSQLRules2SQL {
	NestedIndent :indent =
		-> (indent + '\t'),

	SelectQuery :indent =
		NestedIndent(indent):nestedIndent
		{[]}:tables
		{''}:where
		{''}:groupBy
		{''}:orderBy
		{''}:limit
		{''}:offset
		[	'SelectQuery'
			[	Select:fields
			|	Table(indent):table
				{tables.push(table)}
			|	Where(indent):where
				{indent + where}:where
			|	GroupBy(indent):groupBy
				{indent + groupBy}:groupBy
			|	OrderBy(indent):orderBy
				{indent + orderBy}:orderBy
			|	Limit(indent):limit
				{indent + limit}:limit
			|	Offset(indent):offset
				{indent + offset}:offset
			]*
		]
		-> ('SELECT ' + fields.join(', ') + indent + 'FROM ' + tables.join(',' + nestedIndent) + where + groupBy + orderBy + limit + offset),

	DeleteQuery :indent =
		{[]}:tables
		{''}:where
		[	'DeleteQuery'
			[	Table(indent):table
				{tables.push(table)}
			|	Where(indent):where
				{indent + where}:where
			]*
		]
		-> ('DELETE FROM ' + tables.join(', ') + where),

	UpsertQuery :indent =
		[	'UpsertQuery'
			&InsertBody(indent):insert
			{{query: insert, bindings: this.fieldOrderings}}:insert
			{this.fieldOrderings = []}
			UpdateBody(indent):update
			{{query: update, bindings: this.fieldOrderings}}:update
		]
		-> [insert, update],

	InsertQuery :indent =
		[	'InsertQuery'
			InsertBody(indent):insert
		]
		-> insert,

	UpdateQuery :indent =
		[	'UpdateQuery'
			UpdateBody(indent):update
		]
		-> update,

	InsertBody :indent =
		{[]}:tables
		[	Fields:fieldValues
		|	Table(indent):table
			{tables.push(table)}
		|	// Ignore a where - we're probably in an Upsert.
			'Where'
			anything*
		]*
		(	?(fieldValues[0].length > 0)
			-> ('INSERT INTO ' + tables.join(', ') + ' (' + fieldValues[0].join(', ') + ')' + indent + 'VALUES (' + fieldValues[1].join(', ') + ')')
		|	-> ('INSERT INTO ' + tables.join(', ') + ' DEFAULT VALUES')
		),

	UpdateBody :indent =
		{[]}:tables
		{''}:where
		[	Fields:fieldValues
		|	Table(indent):table
			{tables.push(table)}
		|	Where(indent):where
			{indent + where}:where
		]*
		{[]}:sets
		{	for(var i=0; i < fieldValues[0].length; i++) {
				sets[i] = fieldValues[0][i] + ' = ' + fieldValues[1][i];
			}
		}
		NestedIndent(indent):nestedIndent
		-> ('UPDATE ' + tables.join(', ') + indent + 'SET ' + sets.join(',' + nestedIndent) + where),

	Fields =
		'Fields'
		{[]}:fields
		{[]}:values
		[	[	anything:field
				{fields.push('"' + field + '"')}
				(	'?'
				|	true
					-> 1
				|	false
					-> 0
				|	Null
					-> 'NULL'
				|	Bind
				|	anything:value
					// TODO: Should escape this.
					-> ("'" + value + "'")
				):value
				{values.push(value)}
			]+
		]
		-> [fields, values],

	Select =
		'Select'
		[	end
			{['1']}:fields
		|	(	[	(	'Count'
						'*'
						-> 'COUNT(*)'
					|	:table
						'*'
						-> ('"' + table + '".*')
					|	AnyValue:value
						anything:as
						-> (value + ' AS "' + as + '"')
					):field
				]
				-> field
			|	AnyValue
			|	'*'
			|	Null
				-> 'NULL'
			)*:fields
		]
		-> fields,

	Table :indent =
		'From'
		NestedIndent(indent):indent
		NestedIndent(indent):nestedIndent
		(	~string
			[	(	SelectQuery(nestedIndent):query
					-> ('(\t' + query + indent + ')')
				|	anything:table
					-> ('"' + table + '"')
				):from
				anything:alias
			]
			-> (from + ' AS "' + alias + '"')
		|	SelectQuery(nestedIndent)
			-> ('(\t' + query + indent + ')')
		|	anything:table
			-> ('"' + table + '"')
		),

	Where :indent =
		'Where'
		BooleanValue(indent):ruleBody
		-> ('WHERE ' + ruleBody),

	GroupBy :indent =
		'GroupBy'
		[	AnyValue(indent)+:values
		]
		-> ('GROUP BY ' + values.join(', ')),

	OrderBy :indent =
		'OrderBy'
		(	[	(	'ASC'
				|	'DESC'
				):order
				(	Field
				|	ReferencedField
				):field
			]
			-> (field + ' ' + order)
		)+:orders
		NestedIndent(indent):nestedIndent
		-> ('ORDER BY ' + orders.join(',' + nestedIndent)),

	Limit :indent =
		'Limit'
		NumericValue(indent):num
		-> ('LIMIT ' + num),

	Offset :indent =
		'Offset'
		NumericValue(indent):num
		-> ('OFFSET ' + num),

	AnyValue :indent =
		(	UnknownValue(indent)
		|	TextValue(indent)
		|	NumericValue(indent)
		|	BooleanValue(indent)
		|	DateValue(indent)
		|	JSONValue(indent)
		),

	UnknownValue :indent =
		(	ReferencedField
		|	Field
		|	Bind
		|	Null
		|	NestedIndent(indent):nestedIndent
			SelectQuery(nestedIndent):query
			-> ('(' + nestedIndent + query + indent + ')')
		),

	Field =
		[	'Field'
			:field
		]
		-> ('"' + field + '"'),

	ReferencedField =
		[	'ReferencedField'
			:table
			:field
		]
		-> ('"' + table + '"."' + field + '"'),

	Bind =
		[	'Bind'
			:tableName
			:field
		]
		{this.fieldOrderings.push([tableName, field])}
		-> '?',

	Null =
		:next
		?(next===null)
		-> null,

	TextValue :indent =
		(	UnknownValue(indent)
		|	Text
		|	Concat(indent)
		),

	Text =
		[	(	'Value'
			|	'Text'
			)
			:text
		]
		// TODO: This should have quotes escaped
		-> ("'" + text + "'"),

	Concat :indent =
		[	(	'Concat'
			|	'Concatenate'
			)
			TextValue(indent)+:comparators
		]
		(	?(this.engine == 'mysql')
			-> ('CONCAT(' + comparators.join(', ') + ')')
		|	-> ('(' + comparators.join(' || ') + ')')
		),

	NumericValue :indent =
		(	UnknownValue(indent)
		|	Number
		|	MathOp(indent)
		|	BitwiseAnd(indent)
		|	BitwiseShiftRight(indent)
		|	CharacterLength(indent)
		),

	// TODO: Integer should actually be separate from number, for the case of bitwise operations that need an integral type.
	Number =
		[	(	'Number'
			|	'Real'
			|	'Integer'
			)
			:number
		]
		-> number,

	MathOp :indent =
		[	(	'Add'
				-> '+'
			|	'Subtract'
				-> '-'
			|	'Multiply'
				-> '*'
			|	'Divide'
				-> '/'
			):op
			NumericValue(indent):lhs
			NumericValue(indent):rhs
		]
		-> [lhs, op, rhs].join(' '),

	BitwiseAnd :indent =
		[	'BitwiseAnd'
			NumericValue(indent):operand
			NumericValue(indent):mask
		]
		-> ('(' + operand + ' & ' + mask + ')'),

	BitwiseShiftRight :indent =
		[	'BitwiseShiftRight'
			NumericValue(indent):operand
			NumericValue(indent):shift
		]
		-> ('(' + operand + ' >> ' + shift + ')'),

	CharacterLength :indent =
		[	'CharacterLength'
			TextValue(indent):text
		]
		(	?(this.engine == 'mysql')
			-> ('CHAR_LENGTH(' + text + ')')
		|	-> ('LENGTH(' + text + ')')
		),

	BooleanValue :indent =
		(	UnknownValue(indent)
		|	Boolean
		|	And(indent)
		|	Not(indent)
		|	Or(indent)
		|	Exists(indent)
		|	Comparison(indent)
		|	Between(indent)
		),

	Boolean =
		[	'Boolean'
			(	true
				-> 1
			|	false
				-> 0
			):bool
		]
		-> bool,

	Not :indent =
		[	'Not'
			NestedIndent(indent):nestedIndent
			BooleanValue(nestedIndent):bool
		]
		-> ('NOT (' + nestedIndent + bool + indent + ')'),

	And :indent =
		[	'And'
			BooleanValue(indent)*:bools
		]
		-> bools.join(indent + 'AND '),

	Or :indent =
		[	'Or'
			BooleanValue(indent)*:bools
		]
		-> ('(' + bools.join(indent + 'OR ') + ')'),

	Exists :indent =
		[	'Exists'
			(	// We need to create a SelectQuery differently to other comparators, so we check for it first.
				NestedIndent(indent):nestedIndent
				SelectQuery(nestedIndent):ruleBody
				-> ('EXISTS (' + nestedIndent + ruleBody + indent + ')')
			|	AnyValue(indent):comparator
				-> (comparator + ' IS NOT NULL')
			):exists
		]
		-> exists,

	Comparison :indent =
		[	(	'Equals'
			|	'GreaterThan'
			|	'GreaterThanOrEqual'
			|	'LessThan'
			|	'LessThanOrEqual'
			|	'NotEquals'
			|	'Like'
			):comparison
			AnyValue(indent):a
			AnyValue(indent):b
		]
		-> (a + comparisons[comparison] + b),

	Between :indent =
		[	'Between'
			AnyValue(indent):val
			AnyValue(indent):a
			AnyValue(indent):b
		]
		-> (val + ' BETWEEN ' + a + ' AND ' + b),

	DateValue :indent =
		(	UnknownValue(indent)
		|	Date(indent)
		),

	Date :indent =
		[	'Date'
			anything:date
		]
		{this.fieldOrderings.push(['Date', date])}
		-> '?',

	JSONValue :indent =
		(	UnknownValue(indent)
		|	AggregateJSON(indent)
		),

	AggregateJSON :indent =
		[	'AggregateJSON'
			[	:table
				(	'*'
				|	anything:field
					-> ('"' + field + '"')
				):field
			]
		]
		{'"' + table + '".' + field}:field
		(	?(this.engine == 'postgres')
			-> ('array_to_json(array_agg(' + field + '))')
		|	-> ("'[' || group_concat(" + field + ", ',') || ']'")
		),

	Process =
			{this.fieldOrderings = []}
			(	SelectQuery('\n')
			|	InsertQuery('\n')
			|	UpdateQuery('\n')
			|	DeleteQuery('\n')
			):query
			-> {query: query, bindings: this.fieldOrderings}
		|	UpsertQuery('\n')
		|	AnyValue('\n'):value
			-> ('SELECT ' + value + ' AS "result";')
}
