// Generated by CoffeeScript 1.12.6
(function() {
  var hasProp = {}.hasOwnProperty;

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define(['@resin/abstract-sql-compiler/AbstractSQLOptimiser', '@resin/abstract-sql-compiler/AbstractSQLRules2SQL', '@resin/sbvr-types', 'lodash', 'bluebird'], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory(require('./AbstractSQLOptimiser'), require('./AbstractSQLRules2SQL'), require('@resin/sbvr-types'), require('lodash'), require('bluebird'));
    } else {
      return root.AbstractSQLCompiler = factory(root.AbstractSQLOptimiser, root.AbstractSQLRules2SQL, root.sbvrTypes, root._, root.Promise);
    }
  })(this, function(arg, arg1, sbvrTypes, _, Promise) {
    var AbstractSQLOptimiser, AbstractSQLRules2SQL, compileRule, compileSchema, dataTypeGen, dataTypeValidate, getModifiedFields, getReferencedFields, validateTypes;
    AbstractSQLOptimiser = arg.AbstractSQLOptimiser;
    AbstractSQLRules2SQL = arg1.AbstractSQLRules2SQL;
    validateTypes = _.mapValues(sbvrTypes, function(arg2) {
      var validate;
      validate = arg2.validate;
      if (validate != null) {
        return Promise.promisify(validate);
      }
    });
    dataTypeValidate = function(value, field, callback) {
      var dataType, required;
      dataType = field.dataType, required = field.required;
      if (value === null) {
        if (required) {
          return Promise.rejected('cannot be null');
        } else {
          return Promise.fulfilled(null);
        }
      } else if (validateTypes[dataType] != null) {
        return validateTypes[dataType](value, required);
      } else {
        return Promise.rejected('is an unsupported type: ' + dataType);
      }
    };
    dataTypeGen = function(engine, dataType, necessity, index, defaultValue) {
      var dbType, ref, ref1;
      if (index == null) {
        index = '';
      }
      necessity = necessity ? ' NOT NULL' : ' NULL';
      defaultValue = defaultValue ? " DEFAULT " + defaultValue : void 0;
      if (index !== '') {
        index = ' ' + index;
      }
      dbType = (ref = sbvrTypes[dataType]) != null ? (ref1 = ref.types) != null ? ref1[engine] : void 0 : void 0;
      if (dbType != null) {
        if (_.isFunction(dbType)) {
          return dbType(necessity, index);
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        return dbType + defaultValue + necessity + index;
      } else {
        throw new Error("Unknown data type '" + dataType + "' for engine: " + engine);
      }
    };
    getReferencedFields = function(ruleBody) {
      var alias, aliasFields, recurse, ref, ref1, referencedFields, table, tableAliases, tableFields;
      tableAliases = {};
      referencedFields = {};
      recurse = function(rulePart) {
        return _.each(rulePart, function(part) {
          var alias, name, nested, table;
          if (_.isArray(part)) {
            if (part[0] === 'ReferencedField') {
              if (referencedFields[name = part[1]] == null) {
                referencedFields[name] = [];
              }
              referencedFields[part[1]].push(part[2]);
              return;
            }
            if (part[0] === 'Field') {
              throw new Error('Cannot find queried fields for unreferenced fields');
            }
            if (part[0] === 'From') {
              if (_.isArray(part[1])) {
                nested = part[1];
                if (_.isArray(nested[1])) {
                  throw new Error('Cannot handle aliased select queries');
                }
                table = nested[0];
                alias = nested[1];
                tableAliases[alias] = table;
              }
            }
            return recurse(part);
          }
        });
      };
      recurse(ruleBody);
      for (alias in tableAliases) {
        table = tableAliases[alias];
        tableFields = (ref = referencedFields[table]) != null ? ref : [];
        aliasFields = (ref1 = referencedFields[alias]) != null ? ref1 : [];
        referencedFields[table] = tableFields.concat(aliasFields);
      }
      return referencedFields;
    };
    getModifiedFields = (function() {
      var checkQuery;
      checkQuery = function(query) {
        var fields, froms, queryType, table;
        queryType = query[0];
        if (queryType !== 'InsertQuery' && queryType !== 'UpdateQuery' && queryType !== 'DeleteQuery') {
          return;
        }
        froms = _.filter(query, {
          0: 'From'
        });
        if (froms.length !== 1) {
          return;
        }
        table = froms[0][1];
        if (queryType === 'InsertQuery' || queryType === 'DeleteQuery') {
          return {
            table: table
          };
        }
        fields = _.filter(query, {
          0: 'Fields'
        });
        fields = _.flatMap(fields, 1);
        return {
          table: table,
          fields: fields
        };
      };
      return function(abstractSqlQuery) {
        if (_.isArray(abstractSqlQuery[0])) {
          return _.map(abstractSqlQuery, checkQuery);
        } else {
          return checkQuery(abstractSqlQuery);
        }
      };
    })();
    compileRule = (function() {
      var compiler, optimiser;
      optimiser = AbstractSQLOptimiser.createInstance();
      compiler = AbstractSQLRules2SQL.createInstance();
      return function(abstractSQL, engine) {
        abstractSQL = optimiser.match(abstractSQL, 'Process');
        compiler.engine = engine;
        return compiler.match(abstractSQL, 'Process');
      };
    })();
    compileSchema = function(sqlModel, engine, ifNotExists) {
      var createSQL, createSchemaStatements, dataType, defaultValue, dependency, depends, dropSQL, dropSchemaStatements, e, fieldName, foreignKey, foreignKeys, hasDependants, i, index, j, k, l, len, len1, len2, len3, len4, len5, m, n, ref, ref1, ref2, ref3, ref4, ref5, referencedFields, references, required, resourceName, rule, ruleBody, ruleSE, ruleSQL, ruleStatements, schemaDependencyMap, schemaInfo, table, tableName, tableNames, unsolvedDependency;
      ifNotExists = ifNotExists ? 'IF NOT EXISTS ' : '';
      hasDependants = {};
      schemaDependencyMap = {};
      ref = sqlModel.tables;
      for (resourceName in ref) {
        if (!hasProp.call(ref, resourceName)) continue;
        table = ref[resourceName];
        if (!(!_.isString(table))) {
          continue;
        }
        foreignKeys = [];
        depends = [];
        dropSQL = 'DROP TABLE "' + table.name + '";';
        createSQL = 'CREATE TABLE ' + ifNotExists + '"' + table.name + '" (\n\t';
        ref1 = table.fields;
        for (i = 0, len = ref1.length; i < len; i++) {
          ref2 = ref1[i], dataType = ref2.dataType, fieldName = ref2.fieldName, required = ref2.required, index = ref2.index, references = ref2.references, defaultValue = ref2.defaultValue;
          createSQL += '"' + fieldName + '" ' + dataTypeGen(engine, dataType, required, index, defaultValue) + '\n,\t';
          if (dataType === 'ForeignKey' || dataType === 'ConceptType') {
            foreignKeys.push({
              fieldName: fieldName,
              references: references
            });
            depends.push(references.tableName);
            hasDependants[references.tableName] = true;
          }
        }
        for (j = 0, len1 = foreignKeys.length; j < len1; j++) {
          foreignKey = foreignKeys[j];
          createSQL += 'FOREIGN KEY ("' + foreignKey.fieldName + '") REFERENCES "' + foreignKey.references.tableName + '" ("' + foreignKey.references.fieldName + '")' + '\n,\t';
        }
        ref3 = table.indexes;
        for (k = 0, len2 = ref3.length; k < len2; k++) {
          index = ref3[k];
          createSQL += index.type + '("' + index.fields.join('", "') + '")\n,\t';
        }
        createSQL = createSQL.slice(0, -2) + ');';
        schemaDependencyMap[table.name] = {
          resourceName: resourceName,
          primitive: table.primitive,
          createSQL: createSQL,
          dropSQL: dropSQL,
          depends: depends
        };
      }
      createSchemaStatements = [];
      dropSchemaStatements = [];
      tableNames = [];
      while (tableNames.length !== (tableNames = Object.keys(schemaDependencyMap)).length && tableNames.length > 0) {
        for (l = 0, len3 = tableNames.length; l < len3; l++) {
          tableName = tableNames[l];
          schemaInfo = schemaDependencyMap[tableName];
          unsolvedDependency = false;
          ref4 = schemaInfo.depends;
          for (m = 0, len4 = ref4.length; m < len4; m++) {
            dependency = ref4[m];
            if (dependency !== tableName) {
              if (schemaDependencyMap.hasOwnProperty(dependency)) {
                unsolvedDependency = true;
                break;
              }
            }
          }
          if (unsolvedDependency === false) {
            if (sqlModel.tables[schemaInfo.resourceName].exists = schemaInfo.primitive === false || (hasDependants[tableName] != null)) {
              if (schemaInfo.primitive !== false) {
                console.warn("We're adding a primitive table??", schemaInfo.resourceName);
              }
              createSchemaStatements.push(schemaInfo.createSQL);
              dropSchemaStatements.push(schemaInfo.dropSQL);
            }
            delete schemaDependencyMap[tableName];
          }
        }
      }
      if (schemaDependencyMap.length > 0) {
        console.error('Failed to resolve all schema dependencies', schemaDependencyMap);
        throw new Error('Failed to resolve all schema dependencies');
      }
      dropSchemaStatements = dropSchemaStatements.reverse();
      ruleStatements = [];
      try {
        ref5 = sqlModel.rules;
        for (n = 0, len5 = ref5.length; n < len5; n++) {
          rule = ref5[n];
          ruleBody = _.find(rule, {
            0: 'Body'
          })[1];
          ruleSE = _.find(rule, {
            0: 'StructuredEnglish'
          })[1];
          ruleSQL = compileRule(ruleBody, engine);
          try {
            referencedFields = getReferencedFields(ruleBody);
          } catch (error) {
            e = error;
            console.warn('Error fetching referenced fields', e);
          }
          ruleStatements.push({
            structuredEnglish: ruleSE,
            sql: ruleSQL,
            referencedFields: referencedFields
          });
        }
      } catch (error) {
        e = error;
        console.error('Failed to compile the rule', JSON.stringify(rule, null, '\t'));
        console.error(e, e.stack);
        throw e;
      }
      return {
        tables: sqlModel.tables,
        createSchema: createSchemaStatements,
        dropSchema: dropSchemaStatements,
        rules: ruleStatements
      };
    };
    return module.exports = _.mapValues({
      postgres: true,
      mysql: true,
      websql: false
    }, function(ifNotExists, engine) {
      return {
        compileSchema: _.partial(compileSchema, _, engine, ifNotExists),
        compileRule: _.partial(compileRule, _, engine),
        dataTypeValidate: dataTypeValidate,
        getReferencedFields: getReferencedFields,
        getModifiedFields: getModifiedFields
      };
    });
  });

}).call(this);
